# ğŸ“ˆ PyTorch ê¸°ë°˜ ë”¥ëŸ¬ë‹ì„ í™œìš©í•œ ì£¼ê°€ ë“±ë½ ì˜ˆì¸¡ ë° ìë™ë§¤ë§¤ ì‹œë®¬ë ˆì´ì…˜

#### **ê¸°ê³„í•™ìŠµê³¼ì‘ìš© / ì¸í˜•ì§„ (2021131028)**

---

## 1. ëª¨í‹°ë² ì´ì…˜ (í”„ë¡œì íŠ¸ë¥¼ í•˜ê²Œ ëœ ë™ê¸°)

ì§€ë‚œ í•™ê¸° â€˜ìˆ˜í•™ê³¼ í”„ë¡œê·¸ë˜ë°â€™ ìˆ˜ì—…ì—ì„œ ì„ í˜• ì í™”ì‹ì„ ì´ìš©í•œ ì£¼ê°€ ì˜ˆì¸¡ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•˜ë©°, ìˆ˜í•™ì  ëª¨ë¸ë§ì´ ì‹¤ì œ ê¸ˆìœµ ë°ì´í„°ì— ì ìš©ë˜ëŠ” ê³¼ì •ì— í° í¥ë¯¸ë¥¼ ëŠê¼ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë‹¨ìˆœ ì„ í˜• íšŒê·€ ëª¨ë¸ì€ ì£¼ê°€ì˜ ë¹„ì„ í˜•ì ì¸ íŒ¨í„´ê³¼ ê¸‰ê²©í•œ ë³€ë™ì„±ì„ ë‹´ì•„ë‚´ê¸°ì—ëŠ” í•œê³„ê°€ ìˆìŒì„ ì²´ê°í–ˆìŠµë‹ˆë‹¤.

ì´ë²ˆ â€˜ê¸°ê³„í•™ìŠµê³¼ ì‘ìš©â€™ ìˆ˜ì—…ì„ í†µí•´ **ë”¥ëŸ¬ë‹(Deep Learning)**ê³¼ **ë¶„ë¥˜(Classification)** ê¸°ë²•ì„ ë°°ìš°ë©´ì„œ, ê¸°ì¡´ì˜ ì„ í˜• ëª¨ë¸ì„ ë„˜ì–´ì„  ê³ ë„í™”ëœ ì˜ˆì¸¡ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•´ë³´ê³  ì‹¶ì—ˆìŠµë‹ˆë‹¤. íŠ¹íˆ, ìˆ˜ì—…ì˜ í•µì‹¬ì¸ **PyTorch**ë¥¼ í™œìš©í•˜ì—¬ ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ (MLP) ëª¨ë¸ì„ ì§ì ‘ êµ¬í˜„í•˜ê³ , ì´ë¥¼ Scikit-learnì˜ ì „í†µì ì¸ ë¨¸ì‹ ëŸ¬ë‹ ì•Œê³ ë¦¬ì¦˜ë“¤ê³¼ ë¹„êµí•´ ë´„ìœ¼ë¡œì¨ ë”¥ëŸ¬ë‹ì˜ íš¨ìš©ì„±ì„ ê²€ì¦í•˜ê³ ì í•©ë‹ˆë‹¤. ë˜í•œ, ë‹¨ìˆœ ì˜ˆì¸¡ì„ ë„˜ì–´ ìˆ˜ìˆ˜ë£Œì™€ ìŠ¬ë¦¬í”¼ì§€ë¥¼ ê³ ë ¤í•œ í˜„ì‹¤ì ì¸ ë°±í…ŒìŠ¤íŒ…ì„ í†µí•´ ì‹¤ì œ íˆ¬ì ì „ëµìœ¼ë¡œì„œì˜ ê°€ëŠ¥ì„±ì„ í™•ì¸í•´ë³´ê³ ì í•©ë‹ˆë‹¤.

---

## 2. ì´ë¡ ì  ë°°ê²½

* **ì§€ë„ í•™ìŠµ ê¸°ë°˜ì˜ ë¶„ë¥˜ (Supervised Classification)**: ë¯¸ë˜ì˜ êµ¬ì²´ì ì¸ ê°€ê²©(Regression)ì„ ë§ì¶”ëŠ” ê²ƒì€ ë§¤ìš° ì–´ë µê¸° ë•Œë¬¸ì—, ë‚´ì¼ ì£¼ê°€ê°€ ì˜¤ë¥¼ì§€(1) ë‚´ë¦´ì§€(0)ë¥¼ ì˜ˆì¸¡í•˜ëŠ” **ì´ì§„ ë¶„ë¥˜ ë¬¸ì œ**ë¡œ ì •ì˜í•˜ì—¬ ì˜ˆì¸¡ì˜ ì •í™•ë„ë¥¼ ë†’ì…ë‹ˆë‹¤.
* **ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡  (Multi-Layer Perceptron, MLP)**: ì…ë ¥ì¸µê³¼ ì¶œë ¥ì¸µ ì‚¬ì´ì— ì—¬ëŸ¬ ê°œì˜ ì€ë‹‰ì¸µ(Hidden Layer)ì„ ë‘ê³  ë¹„ì„ í˜• í™œì„±í™” í•¨ìˆ˜(ReLU)ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ì˜ ë³µì¡í•œ íŠ¹ì§•ì„ í•™ìŠµí•˜ëŠ” ì¸ê³µì‹ ê²½ë§ì…ë‹ˆë‹¤.
* **í”¼ì²˜ ì—”ì§€ë‹ˆì–´ë§ (Feature Engineering)**: ë‹¨ìˆœíˆ ê³¼ê±° ê°€ê²©ë§Œì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, **ì´ë™í‰ê·  ê´´ë¦¬ìœ¨(MA Ratio)**, **ë³€ë™ì„±(Volatility)**, **ëª¨ë©˜í…€(Momentum)** ë“± ê¸°ìˆ ì  ì§€í‘œë¥¼ ìƒì„±í•˜ì—¬ ëª¨ë¸ì˜ í•™ìŠµ íš¨ìœ¨ì„ ë†’ì…ë‹ˆë‹¤.
* **ë°±í…ŒìŠ¤íŒ… í‰ê°€ì§€í‘œ**:
    * **Sharpe Ratio**: ìœ„í—˜(ë³€ë™ì„±) í•œ ë‹¨ìœ„ë‹¹ ì–»ì„ ìˆ˜ ìˆëŠ” ì´ˆê³¼ ìˆ˜ìµë¥ .
    * **MDD (Maximum Drawdown)**: íŠ¹ì • ê¸°ê°„ ë™ì•ˆ í¬íŠ¸í´ë¦¬ì˜¤ê°€ ê²ªì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì†ì‹¤í­.

---

## 3. ì½”ë“œ ì‘ì„±ë°©ë²• ë° ì„¤ëª…

### í•µì‹¬ êµ¬ì„± ìš”ì†Œ: ë°ì´í„° ì „ì²˜ë¦¬, ëª¨ë¸ë§, ì‹œë®¬ë ˆì´ì…˜ì˜ ëª¨ë“ˆí™”

### 1. `build_features`

> **ì—­í• **: `yfinance`ë¥¼ í†µí•´ ìˆ˜ì§‘ëœ ì›ë³¸ ì£¼ê°€ ë°ì´í„°ì—ì„œ í•™ìŠµì— í•„ìš”í•œ ê¸°ìˆ ì  ì§€í‘œ(Feature)ë¥¼ ìƒì„±í•˜ê³ , ì˜ˆì¸¡ ëª©í‘œ(Target)ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

* **Lag Features**: ê³¼ê±° 10ì¼ê°„ì˜ ë¡œê·¸ ìˆ˜ìµë¥ (`ret_lag_k`)ì„ ìƒì„±í•˜ì—¬ ì‹œê³„ì—´ì  íŒ¨í„´ì„ ë°˜ì˜í•©ë‹ˆë‹¤.
* **MA Ratio**: 5ì¼, 20ì¼ ì´ë™í‰ê· ì„  ëŒ€ë¹„ í˜„ì¬ ê°€ê²©ì˜ ë¹„ìœ¨ì„ ê³„ì‚°í•˜ì—¬ ì¶”ì„¸ ì •ë³´ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
* **Volatility & Momentum**: ë³€ë™ì„±ê³¼ ëª¨ë©˜í…€ ì§€í‘œë¥¼ ì¶”ê°€í•˜ì—¬ ì‹œì¥ì˜ ê³¼ì—´ ì—¬ë¶€ì™€ ë³€ë™ì„± ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
* **Target (`y`)**: ë‹¤ìŒ ë‚ ì˜ ìˆ˜ìµë¥ (`future_ret`)ì´ 0ë³´ë‹¤ í¬ë©´ `1`, ì•„ë‹ˆë©´ `0`ìœ¼ë¡œ ë¼ë²¨ë§í•˜ì—¬ ì´ì§„ ë¶„ë¥˜ ë¬¸ì œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.

```python
def build_features(df: pd.DataFrame, cfg: FeatureConfig) -> pd.DataFrame:
    # ... (ë¡œê·¸ ìˆ˜ìµë¥  ë° Lag ìƒì„±) ...

    # Moving Average Ratio (ì´ë™í‰ê·  ê´´ë¦¬ìœ¨)
    for w in cfg.ma_windows:
        ma = out["price"].rolling(w).mean()
        out[f"ma_ratio_{w}"] = out["price"] / ma - 1.0

    # Target ì„¤ì • (Next Day Return > 0)
    out["future_ret"] = out["ret"].shift(-1)
    out["y"] = (out["future_ret"] > 0).astype(int)

    return out.dropna().reset_index(drop=True)
2. TorchMLP & TorchMLPModel
ì—­í• : PyTorchë¥¼ í™œìš©í•˜ì—¬ ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ (MLP) ëª¨ë¸ì„ êµ¬ì¶•í•˜ê³ , Scikit-learn ìŠ¤íƒ€ì¼ë¡œ í•™ìŠµ ë° ì˜ˆì¸¡ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

TorchMLP(__init__): Linear(64) -> ReLU -> Dropout(0.1) êµ¬ì¡°ë¥¼ 2ì¸µìœ¼ë¡œ ìŒ“ì•„ ë¹„ì„ í˜•ì„±ì„ í•™ìŠµí•˜ë©°, Dropoutì„ í†µí•´ ê³¼ì í•©ì„ ë°©ì§€í•©ë‹ˆë‹¤.

fit(X, y): Adam ì˜µí‹°ë§ˆì´ì €ì™€ BCEWithLogitsLossë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì„ í•™ìŠµí•©ë‹ˆë‹¤. Epochë¥¼ 200íšŒë¡œ ì„¤ì •í•˜ì—¬ ì¶©ë¶„í•œ í•™ìŠµì´ ì´ë£¨ì–´ì§€ë„ë¡ í–ˆìŠµë‹ˆë‹¤.

predict_proba(X): í•™ìŠµëœ ëª¨ë¸ì„ eval() ëª¨ë“œë¡œ ì „í™˜í•˜ê³ , Sigmoid í•¨ìˆ˜ë¥¼ í†µê³¼ì‹œì¼œ 0~1 ì‚¬ì´ì˜ ìƒìŠ¹ í™•ë¥ ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

Python

class TorchMLP(nn.Module):
    def __init__(self, in_dim):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(in_dim, 64),
            nn.ReLU(),
            nn.Dropout(0.1),  # ê³¼ì í•© ë°©ì§€
            nn.Linear(64, 64),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(64, 1)
        )
3. backtest
ì—­í• : ëª¨ë¸ì˜ ì˜ˆì¸¡ í™•ë¥ ì„ ê¸°ë°˜ìœ¼ë¡œ ê°€ìƒì˜ ë§¤ë§¤ë¥¼ ìˆ˜í–‰í•˜ê³ , ìˆ˜ìˆ˜ë£Œì™€ ìŠ¬ë¦¬í”¼ì§€ë¥¼ ë°˜ì˜í•œ ìµœì¢… ìˆ˜ìµë¥ ì„ ê³„ì‚°í•©ë‹ˆë‹¤.

ì—„ê²©í•œ ë§¤ë§¤ ê¸°ì¤€: ìƒìŠ¹ í™•ë¥ ì´ **60% ì´ìƒ(p_buy)**ì¼ ë•Œë§Œ ë§¤ìˆ˜í•˜ê³ , **40% ì´í•˜(p_sell)**ì¼ ë•Œ ë§¤ë„í•˜ëŠ” ê¸°ì¤€ì„ ì ìš©í•˜ì—¬ ì¦ì€ ê±°ë˜ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.

ë¹„ìš© ë°˜ì˜: ë§¤ë§¤ ì‹œ commission(0.05%)ê³¼ slippage(0.05%)ë¥¼ ì°¨ê°í•˜ì—¬ í˜„ì‹¤ì ì¸ ìì‚° ë³€í™”ë¥¼ ì¶”ì í•©ë‹ˆë‹¤.

ì„±ê³¼ ì§€í‘œ ê³„ì‚°: ìµœì¢… ëˆ„ì  ìˆ˜ìµë¥ (CumRet), ìµœëŒ€ ë‚™í­(MDD), ìƒ¤í”„ ì§€ìˆ˜(Sharpe)ë¥¼ ê³„ì‚°í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.

Python

def backtest(prices, probs, cfg: BacktestConfig):
    # ... (ì¤‘ëµ) ...
    for price, p in zip(prices, probs):
        # Buy Signal (60% ì´ìƒ í™•ì‹  ì‹œ)
        if shares == 0 and p >= cfg.p_buy:
            cost = cash * (cfg.commission + cfg.slippage)
            shares = (cash - cost) / price
            cash = 0
            
        # Sell Signal (40% ì´í•˜ í™•ì‹  ì‹œ)
        elif shares > 0 and p <= cfg.p_sell:
            cash = shares * price * (1 - cfg.commission - cfg.slippage)
            shares = 0
4. run
ì—­í• : ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì´ê´„í•˜ë©°, ë°ì´í„° ë¡œë“œ, ëª¨ë¸ í•™ìŠµ, ë²¤ì¹˜ë§ˆí¬ ë¹„êµ, ê²°ê³¼ ì‹œê°í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.

ë²¤ì¹˜ë§ˆí¬ ì„¤ì •: ë‹¨ìˆœíˆ ì£¼ì‹ì„ ë³´ìœ í–ˆì„ ë•Œ(Buy & Hold)ì˜ ìˆ˜ìµë¥ ì„ ê³„ì‚°í•˜ì—¬ ëª¨ë¸ ì„±ëŠ¥ í‰ê°€ì˜ ê¸°ì¤€ì ìœ¼ë¡œ ì‚¼ìŠµë‹ˆë‹¤.

ëª¨ë¸ ë¹„êµ Loop: Logistic Regression, Random Forest, SVM, MLP ëª¨ë¸ì„ ìˆœì°¨ì ìœ¼ë¡œ í•™ìŠµì‹œí‚¤ê³  ë°±í…ŒìŠ¤íŒ…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

ì‹œê°í™”: ìµœì¢…ì ìœ¼ë¡œ ìì‚° ê°€ì¹˜ ë³€í™”(Equity Curve)ì™€ ë‚™í­ ë³€í™”(Drawdown Curve) ê·¸ë˜í”„ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.

Python

def run():
    # ... (ë°ì´í„° ë¡œë“œ ë° ë¶„í• ) ...
    
    # ë²¤ì¹˜ë§ˆí¬ (Buy & Hold) ìˆ˜ìµë¥  ê³„ì‚°
    buy_hold_equity = prices_te / prices_te[0] * bt_cfg.initial_cash

    models = {
        "MLP": TorchMLPModel(X.shape[1]),
        "RF": RandomForestClassifier(...),
        # ...
    }
    
    # ... (ëª¨ë¸ í•™ìŠµ ë° ê·¸ë˜í”„ ì¶œë ¥) ...
4. í”„ë¡œì íŠ¸ì˜ í•œê³„
ì‹œê³„ì—´ íŠ¹ì„±ì˜ ë¯¸ë°˜ì˜: ì‚¬ìš©ëœ MLP(í”¼ë“œí¬ì›Œë“œ ì‹ ê²½ë§)ëŠ” ì‹œê³„ì—´ ë°ì´í„°ì˜ ìˆœì°¨ì (Sequential) ì •ë³´ë¥¼ ì™„ë²½í•˜ê²Œ ê¸°ì–µí•˜ì§€ ëª»í•©ë‹ˆë‹¤. (LSTMì´ë‚˜ Transformer ëª¨ë¸ ë„ì… í•„ìš”)

ì •ì  ì„ê³„ê°’ì˜ í•œê³„: ë§¤ë§¤ ê¸°ì¤€(60%)ì´ ê³ ì •ë˜ì–´ ìˆì–´, ë³€ë™ì„±ì´ í° í•˜ë½ì¥ì´ë‚˜ íš¡ë³´ì¥ì—ì„œëŠ” ìœ ì—°í•˜ê²Œ ëŒ€ì‘í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš°ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.

ê±°ë˜ ë¹„ìš©ì˜ ì˜í–¥: ì˜ˆì¸¡ ì •í™•ë„ê°€ 50%ë¥¼ ë„˜ë”ë¼ë„, ì¦ì€ ë§¤ë§¤ê°€ ë°œìƒí•  ê²½ìš° ìˆ˜ìˆ˜ë£Œ ëˆ„ì ìœ¼ë¡œ ì¸í•´ ìµœì¢… ìˆ˜ìµë¥ ì€ ë§ˆì´ë„ˆìŠ¤ê°€ ë  ìˆ˜ ìˆìŒì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.

5. ì‹¤í–‰ ì˜ˆì‹œ
1) ëª¨ë¸ ì„±ëŠ¥ ë¹„êµí‘œ (Example Output)
(ì‹¤ì œ ì‹¤í–‰ ê²°ê³¼) | Model | ACC | CumRet | MDD | Sharpe | Trades | | :--- | :--- | :--- | :--- | :--- | :--- | | Buy & Hold | N/A | 0.XX | 0.YY | 0.ZZ | 0 | | MLP | 0.5249 | -0.18 | -0.20 | -0.87 | 154 | | RF | 0.5102 | -0.21 | -0.22 | -1.10 | 132 |

2) ìì‚° ê°€ì¹˜ ë³€í™” ê·¸ë˜í”„ (Equity Curve)
ê° ëª¨ë¸ì˜ ìì‚° ê°€ì¹˜ ë³€í™”ë¥¼ Buy & Hold(ì ì„ ) ì „ëµê³¼ ë¹„êµí•œ ê·¸ë˜í”„ì…ë‹ˆë‹¤. (ì‹¤ì œ ì¶œë ¥ëœ Equity Curve ì´ë¯¸ì§€ë¥¼ ì—¬ê¸°ì— ì²¨ë¶€í•˜ì„¸ìš”)

3) ë‚™í­ ë³€í™” ê·¸ë˜í”„ (Drawdown Curve)
ê° ì „ëµì´ ê²ªì€ ìµœëŒ€ ì†ì‹¤í­(Drawdown)ì„ ì‹œê°í™”í•˜ì—¬ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ëŠ¥ë ¥ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. (ì‹¤ì œ ì¶œë ¥ëœ Drawdown Curve ì´ë¯¸ì§€ë¥¼ ì—¬ê¸°ì— ì²¨ë¶€í•˜ì„¸ìš”)

6. ê²°ë¡  ë° ê°œì„ ì 
ì´ë²ˆ í”„ë¡œì íŠ¸ëŠ” ë‹¨ìˆœí•œ ìˆ˜í•™ì  ì í™”ì‹ì„ ë„˜ì–´, PyTorchë¥¼ í™œìš©í•œ ë”¥ëŸ¬ë‹ ëª¨ë¸ì„ ì‹¤ì œ ê¸ˆìœµ ë°ì´í„°ì— ì ìš©í•´ ë³´ì•˜ë‹¤ëŠ” ë° í° ì˜ì˜ê°€ ìˆìŠµë‹ˆë‹¤. 200 Epochsì˜ ì¶©ë¶„í•œ í•™ìŠµê³¼ Dropoutì„ ì ìš©í•œ ê²°ê³¼, **MLP ëª¨ë¸ì´ ê¸°ì¡´ ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸(RF, SVM) ëŒ€ë¹„ ê²½ìŸë ¥ ìˆëŠ” ì •í™•ë„(Accuracy)**ë¥¼ ë³´ì—¬ì£¼ì—ˆìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ ìˆ˜ìˆ˜ë£Œë¥¼ í¬í•¨í•œ ì—„ê²©í•œ ë°±í…ŒìŠ¤íŒ… í™˜ê²½ì—ì„œëŠ” ë‹¨ìˆœí•œ 'Buy & Hold' ì „ëµì„ ì´ê¸°ëŠ” ê²ƒì´ ì‰½ì§€ ì•ŠìŒì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì´ëŠ” ë‹¨ìˆœí•œ ë“±ë½ ì˜ˆì¸¡ì„ ë„˜ì–´, **'í™•ì‹¤í•œ ê¸°íšŒì—ë§Œ ë² íŒ…'**í•˜ê³  'ìì‚°ì„ ì§€í‚¤ëŠ”(Drawdown ë°©ì–´)' ì „ëµì´ ë” ì¤‘ìš”í•¨ì„ ì‹œì‚¬í•©ë‹ˆë‹¤.

í–¥í›„ ë°œì „ ë°©í–¥ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

ì‹œê³„ì—´ íŠ¹í™” ëª¨ë¸ ë„ì…: MLP ëŒ€ì‹  **LSTM(Long Short-Term Memory)**ì´ë‚˜ GRU ëª¨ë¸ì„ ì ìš©í•˜ì—¬ ì‹œê³„ì—´ ë°ì´í„°ì˜ ì¥ê¸° ì˜ì¡´ì„±ì„ í•™ìŠµ.

ë™ì  ì„ê³„ê°’: ì‹œì¥ì˜ ë³€ë™ì„±(VIX ë“±)ì— ë”°ë¼ ë§¤ìˆ˜/ë§¤ë„ ê¸°ì¤€ í™•ë¥ ì„ ë™ì ìœ¼ë¡œ ì¡°ì ˆí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ë„ì….

ì•™ìƒë¸” ì „ëµ: MLPì˜ ì˜ˆì¸¡ê°’ê³¼ Random Forestì˜ ë³€ìˆ˜ ì¤‘ìš”ë„ë¥¼ ê²°í•©í•˜ì—¬ ì˜ˆì¸¡ì˜ ì•ˆì •ì„± í™•ë³´.

ì§€ë‚œ í•™ê¸° í”„ë¡œì íŠ¸ê°€ 'êµ¬í˜„'ì— ì´ˆì ì„ ë§ì·„ë‹¤ë©´, ì´ë²ˆ í•™ê¸°ëŠ” **'ë°ì´í„° ê¸°ë°˜ì˜ ì˜ì‚¬ê²°ì •'ê³¼ 'ë”¥ëŸ¬ë‹ì˜ ì‹¤ë¬´ì  ê²€ì¦'**ì„ ê²½í—˜í•˜ëŠ” ê°’ì§„ ì‹œê°„ì´ì—ˆìŠµë‹ˆë‹¤.

ì‚¬ìš©í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬
Python

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf

# Machine Learning
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score

# Deep Learning (PyTorch)
import torch
import torch.nn as nn
from torch.utils.data import DataLoader, TensorDataset
